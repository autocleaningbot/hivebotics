# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from cartesian_impedance_msgs/SetCartesianImpedance.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import cartesian_impedance_msgs.msg
import geometry_msgs.msg

class SetCartesianImpedance(genpy.Message):
  _md5sum = "b24937cc6fdd3861e00c0a10eecbfb67"
  _type = "cartesian_impedance_msgs/SetCartesianImpedance"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """# Here we combine all the parameters message definitions into a single message
# that needs to be send to the controller in order to adjust the Cartesian Impedance Parameters

string                 tool
CartesianStiffness     stiffness
#use this if the damping parameters are defined as ratios (Lehr's damping ratio)
CartesianDamping       damping
MaxCartesianVelocity   max_cart_vel
MaxControlForce        max_ctrl_force
MaxPathDeviation       max_path_deviation
NullSpace              null_space_params

================================================================================
MSG: cartesian_impedance_msgs/CartesianStiffness
# Stiffness parameters for the Cartesian Impedance
# the values are divided into translational and rotational
# each of the translational and rotational components is defined as Vector3

# [N/m]
geometry_msgs/Vector3 translational
# [Nm/rad]
geometry_msgs/Vector3 rotational

================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: cartesian_impedance_msgs/CartesianDamping
# Damping parameters for the Cartesian Impedance
# the values are divided into translational and rotational
# each of the translational and rotational components is defined as Vector3

# Spring damping (type: double)
# The spring damping determines the extent to which the virtual springs
# oscillate after deflection.
# For all degrees of freedom (without unit: Lehr’s damping ratio)

# [ratio:0.1-1.0]
geometry_msgs/Vector3 translational
# [ratio:0.1-1.0]
geometry_msgs/Vector3 rotational

================================================================================
MSG: cartesian_impedance_msgs/MaxCartesianVelocity
# parameters for Maximum allowed Cartesian Velocity when in Cartesian Impedance
# the values are divided into translational and rotational
# the overall message is defined as Twist.
# The Twist message is composed of:
#  1. geometry_msgs/Vector3 linear
#  2. geometry_msgs/Vector3 angular

# trans: [m/s]
# rotation: [rad/s]
geometry_msgs/Twist set

================================================================================
MSG: geometry_msgs/Twist
# This expresses velocity in free space broken into its linear and angular parts.
Vector3  linear
Vector3  angular

================================================================================
MSG: cartesian_impedance_msgs/MaxControlForce
# parameters for Maximum allowed Cartesian Force when in Cartesian Impedance
# This is not the values that the user needs to set for Force Control on the controller
# these parameters are just a safety set and if the controller exceeds the maximum external force
# the user can provide different alternatives, e.g. stop the motion or move away the robot from the object.

# Wrench is defined with two components:
# Vector3  force
# Vector3  torque

# xyz: Newtons  (all >=0)
# rpy:Nm
geometry_msgs/Wrench set

# handler if max control force is exceeded
 MaxCtrlForceExceeded exceeded_action

================================================================================
MSG: geometry_msgs/Wrench
# This represents force in free space, separated into
# its linear and angular parts.
Vector3  force
Vector3  torque

================================================================================
MSG: cartesian_impedance_msgs/MaxCtrlForceExceeded
# Message for handling different actions if the end-effector
# exceeds maximum force set in the Cartesian Impedance parameters

bool stop
bool gravity_compensation
bool move_away

================================================================================
MSG: cartesian_impedance_msgs/MaxPathDeviation
# parameters for Maximum allowed Path Deviation from goal when in Cartesian Impedance
# the values are divided into translational and rotational
# each of the translational and rotational components is defined as Vector3

# maximum deviation from set goal in m
geometry_msgs/Vector3 translation

# maximum deviation from set goal in radians
geometry_msgs/Vector3 rotation

================================================================================
MSG: cartesian_impedance_msgs/NullSpace
# parameters for a redundant joint of the robot when in Cartesian Impedance
# the values are divided into translational and rotational
# each of the translational and rotational components is defined as Float64

# Kinematically, the manipulator's null space describes the motions
# the arm can make that don't move the end effector, known shorthand as "self-motion";
# for a standard 7 DOF revolute RPRPRPR manipulator this is usually equivalent to moving the elbow.
# The range of self-motion for a manipulator is a mathematically well defined space.
# Khatib et al., 1987

string[] link_names

# [Nm/rad] must be => 0.0
float64[] stiffness

# without unit: Lehr’s damping ratio
# must be between 0.3-1.0 suggested is 0.7
float64[] damping
"""
  __slots__ = ['tool','stiffness','damping','max_cart_vel','max_ctrl_force','max_path_deviation','null_space_params']
  _slot_types = ['string','cartesian_impedance_msgs/CartesianStiffness','cartesian_impedance_msgs/CartesianDamping','cartesian_impedance_msgs/MaxCartesianVelocity','cartesian_impedance_msgs/MaxControlForce','cartesian_impedance_msgs/MaxPathDeviation','cartesian_impedance_msgs/NullSpace']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       tool,stiffness,damping,max_cart_vel,max_ctrl_force,max_path_deviation,null_space_params

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(SetCartesianImpedance, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.tool is None:
        self.tool = ''
      if self.stiffness is None:
        self.stiffness = cartesian_impedance_msgs.msg.CartesianStiffness()
      if self.damping is None:
        self.damping = cartesian_impedance_msgs.msg.CartesianDamping()
      if self.max_cart_vel is None:
        self.max_cart_vel = cartesian_impedance_msgs.msg.MaxCartesianVelocity()
      if self.max_ctrl_force is None:
        self.max_ctrl_force = cartesian_impedance_msgs.msg.MaxControlForce()
      if self.max_path_deviation is None:
        self.max_path_deviation = cartesian_impedance_msgs.msg.MaxPathDeviation()
      if self.null_space_params is None:
        self.null_space_params = cartesian_impedance_msgs.msg.NullSpace()
    else:
      self.tool = ''
      self.stiffness = cartesian_impedance_msgs.msg.CartesianStiffness()
      self.damping = cartesian_impedance_msgs.msg.CartesianDamping()
      self.max_cart_vel = cartesian_impedance_msgs.msg.MaxCartesianVelocity()
      self.max_ctrl_force = cartesian_impedance_msgs.msg.MaxControlForce()
      self.max_path_deviation = cartesian_impedance_msgs.msg.MaxPathDeviation()
      self.null_space_params = cartesian_impedance_msgs.msg.NullSpace()

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self.tool
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_24d3B6d().pack(_x.stiffness.translational.x, _x.stiffness.translational.y, _x.stiffness.translational.z, _x.stiffness.rotational.x, _x.stiffness.rotational.y, _x.stiffness.rotational.z, _x.damping.translational.x, _x.damping.translational.y, _x.damping.translational.z, _x.damping.rotational.x, _x.damping.rotational.y, _x.damping.rotational.z, _x.max_cart_vel.set.linear.x, _x.max_cart_vel.set.linear.y, _x.max_cart_vel.set.linear.z, _x.max_cart_vel.set.angular.x, _x.max_cart_vel.set.angular.y, _x.max_cart_vel.set.angular.z, _x.max_ctrl_force.set.force.x, _x.max_ctrl_force.set.force.y, _x.max_ctrl_force.set.force.z, _x.max_ctrl_force.set.torque.x, _x.max_ctrl_force.set.torque.y, _x.max_ctrl_force.set.torque.z, _x.max_ctrl_force.exceeded_action.stop, _x.max_ctrl_force.exceeded_action.gravity_compensation, _x.max_ctrl_force.exceeded_action.move_away, _x.max_path_deviation.translation.x, _x.max_path_deviation.translation.y, _x.max_path_deviation.translation.z, _x.max_path_deviation.rotation.x, _x.max_path_deviation.rotation.y, _x.max_path_deviation.rotation.z))
      length = len(self.null_space_params.link_names)
      buff.write(_struct_I.pack(length))
      for val1 in self.null_space_params.link_names:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      length = len(self.null_space_params.stiffness)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.Struct(pattern).pack(*self.null_space_params.stiffness))
      length = len(self.null_space_params.damping)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.Struct(pattern).pack(*self.null_space_params.damping))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.stiffness is None:
        self.stiffness = cartesian_impedance_msgs.msg.CartesianStiffness()
      if self.damping is None:
        self.damping = cartesian_impedance_msgs.msg.CartesianDamping()
      if self.max_cart_vel is None:
        self.max_cart_vel = cartesian_impedance_msgs.msg.MaxCartesianVelocity()
      if self.max_ctrl_force is None:
        self.max_ctrl_force = cartesian_impedance_msgs.msg.MaxControlForce()
      if self.max_path_deviation is None:
        self.max_path_deviation = cartesian_impedance_msgs.msg.MaxPathDeviation()
      if self.null_space_params is None:
        self.null_space_params = cartesian_impedance_msgs.msg.NullSpace()
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.tool = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.tool = str[start:end]
      _x = self
      start = end
      end += 243
      (_x.stiffness.translational.x, _x.stiffness.translational.y, _x.stiffness.translational.z, _x.stiffness.rotational.x, _x.stiffness.rotational.y, _x.stiffness.rotational.z, _x.damping.translational.x, _x.damping.translational.y, _x.damping.translational.z, _x.damping.rotational.x, _x.damping.rotational.y, _x.damping.rotational.z, _x.max_cart_vel.set.linear.x, _x.max_cart_vel.set.linear.y, _x.max_cart_vel.set.linear.z, _x.max_cart_vel.set.angular.x, _x.max_cart_vel.set.angular.y, _x.max_cart_vel.set.angular.z, _x.max_ctrl_force.set.force.x, _x.max_ctrl_force.set.force.y, _x.max_ctrl_force.set.force.z, _x.max_ctrl_force.set.torque.x, _x.max_ctrl_force.set.torque.y, _x.max_ctrl_force.set.torque.z, _x.max_ctrl_force.exceeded_action.stop, _x.max_ctrl_force.exceeded_action.gravity_compensation, _x.max_ctrl_force.exceeded_action.move_away, _x.max_path_deviation.translation.x, _x.max_path_deviation.translation.y, _x.max_path_deviation.translation.z, _x.max_path_deviation.rotation.x, _x.max_path_deviation.rotation.y, _x.max_path_deviation.rotation.z,) = _get_struct_24d3B6d().unpack(str[start:end])
      self.max_ctrl_force.exceeded_action.stop = bool(self.max_ctrl_force.exceeded_action.stop)
      self.max_ctrl_force.exceeded_action.gravity_compensation = bool(self.max_ctrl_force.exceeded_action.gravity_compensation)
      self.max_ctrl_force.exceeded_action.move_away = bool(self.max_ctrl_force.exceeded_action.move_away)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.null_space_params.link_names = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.null_space_params.link_names.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.null_space_params.stiffness = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.null_space_params.damping = s.unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self.tool
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_24d3B6d().pack(_x.stiffness.translational.x, _x.stiffness.translational.y, _x.stiffness.translational.z, _x.stiffness.rotational.x, _x.stiffness.rotational.y, _x.stiffness.rotational.z, _x.damping.translational.x, _x.damping.translational.y, _x.damping.translational.z, _x.damping.rotational.x, _x.damping.rotational.y, _x.damping.rotational.z, _x.max_cart_vel.set.linear.x, _x.max_cart_vel.set.linear.y, _x.max_cart_vel.set.linear.z, _x.max_cart_vel.set.angular.x, _x.max_cart_vel.set.angular.y, _x.max_cart_vel.set.angular.z, _x.max_ctrl_force.set.force.x, _x.max_ctrl_force.set.force.y, _x.max_ctrl_force.set.force.z, _x.max_ctrl_force.set.torque.x, _x.max_ctrl_force.set.torque.y, _x.max_ctrl_force.set.torque.z, _x.max_ctrl_force.exceeded_action.stop, _x.max_ctrl_force.exceeded_action.gravity_compensation, _x.max_ctrl_force.exceeded_action.move_away, _x.max_path_deviation.translation.x, _x.max_path_deviation.translation.y, _x.max_path_deviation.translation.z, _x.max_path_deviation.rotation.x, _x.max_path_deviation.rotation.y, _x.max_path_deviation.rotation.z))
      length = len(self.null_space_params.link_names)
      buff.write(_struct_I.pack(length))
      for val1 in self.null_space_params.link_names:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      length = len(self.null_space_params.stiffness)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.null_space_params.stiffness.tostring())
      length = len(self.null_space_params.damping)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.null_space_params.damping.tostring())
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.stiffness is None:
        self.stiffness = cartesian_impedance_msgs.msg.CartesianStiffness()
      if self.damping is None:
        self.damping = cartesian_impedance_msgs.msg.CartesianDamping()
      if self.max_cart_vel is None:
        self.max_cart_vel = cartesian_impedance_msgs.msg.MaxCartesianVelocity()
      if self.max_ctrl_force is None:
        self.max_ctrl_force = cartesian_impedance_msgs.msg.MaxControlForce()
      if self.max_path_deviation is None:
        self.max_path_deviation = cartesian_impedance_msgs.msg.MaxPathDeviation()
      if self.null_space_params is None:
        self.null_space_params = cartesian_impedance_msgs.msg.NullSpace()
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.tool = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.tool = str[start:end]
      _x = self
      start = end
      end += 243
      (_x.stiffness.translational.x, _x.stiffness.translational.y, _x.stiffness.translational.z, _x.stiffness.rotational.x, _x.stiffness.rotational.y, _x.stiffness.rotational.z, _x.damping.translational.x, _x.damping.translational.y, _x.damping.translational.z, _x.damping.rotational.x, _x.damping.rotational.y, _x.damping.rotational.z, _x.max_cart_vel.set.linear.x, _x.max_cart_vel.set.linear.y, _x.max_cart_vel.set.linear.z, _x.max_cart_vel.set.angular.x, _x.max_cart_vel.set.angular.y, _x.max_cart_vel.set.angular.z, _x.max_ctrl_force.set.force.x, _x.max_ctrl_force.set.force.y, _x.max_ctrl_force.set.force.z, _x.max_ctrl_force.set.torque.x, _x.max_ctrl_force.set.torque.y, _x.max_ctrl_force.set.torque.z, _x.max_ctrl_force.exceeded_action.stop, _x.max_ctrl_force.exceeded_action.gravity_compensation, _x.max_ctrl_force.exceeded_action.move_away, _x.max_path_deviation.translation.x, _x.max_path_deviation.translation.y, _x.max_path_deviation.translation.z, _x.max_path_deviation.rotation.x, _x.max_path_deviation.rotation.y, _x.max_path_deviation.rotation.z,) = _get_struct_24d3B6d().unpack(str[start:end])
      self.max_ctrl_force.exceeded_action.stop = bool(self.max_ctrl_force.exceeded_action.stop)
      self.max_ctrl_force.exceeded_action.gravity_compensation = bool(self.max_ctrl_force.exceeded_action.gravity_compensation)
      self.max_ctrl_force.exceeded_action.move_away = bool(self.max_ctrl_force.exceeded_action.move_away)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.null_space_params.link_names = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.null_space_params.link_names.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.null_space_params.stiffness = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.null_space_params.damping = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_24d3B6d = None
def _get_struct_24d3B6d():
    global _struct_24d3B6d
    if _struct_24d3B6d is None:
        _struct_24d3B6d = struct.Struct("<24d3B6d")
    return _struct_24d3B6d
